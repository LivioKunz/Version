// --------------------------------------------------------------------------------------------------------------------
// <copyright file="VersionTask.cs" company="Appccelerate">
//   Copyright (c) 2008-2014
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
// </copyright>
// --------------------------------------------------------------------------------------------------------------------

namespace Appccelerate.VersionTask
{
    using System;
    using System.IO;
    using System.Linq;
    using System.Xml;

    using Appccelerate.Version;
    using Appccelerate.VersionTask.Annotations;

    using Microsoft.Build.Evaluation;
    using Microsoft.Build.Framework;
    using Microsoft.Build.Utilities;

    using Newtonsoft.Json;
    using Newtonsoft.Json.Linq;

    public class VersionTask : Task
    {
        [Required]
        public string SolutionDirectory { get; [UsedImplicitly] set; }

        [Required]
        public string ProjectFile { get; [UsedImplicitly] set; }

        [Output]
        public string TempAssemblyInfoFilePath { get; [UsedImplicitly] set; }

        public override bool Execute()
        {
            try
            {
                var repositoryVersionInformation = this.GetRepositoryVersionInformation();

                this.Log.LogMessage(MessageImportance.Normal, "version pattern = " + repositoryVersionInformation.LastTaggedVersion + ", commits since tag = " + repositoryVersionInformation.CommitsSinceLastTaggedVersion);

                var version = CalculateVersion(repositoryVersionInformation);

                this.Log.LogMessage(MessageImportance.Normal, "Version: " + version.Version);
                this.Log.LogMessage(MessageImportance.Normal, "NugetVersion: " + version.NugetVersion);
                this.Log.LogMessage(MessageImportance.Normal, "InformationalVersion: " + version.InformationalVersion);
                this.Log.LogMessage(MessageImportance.Normal, "PrereleaseOverride: " + repositoryVersionInformation.PrereleaseOverride);

                this.WriteAssemblyInfoContaining(version);

                return true;
            }
            catch (Exception exception)
            {
                this.Log.LogErrorFromException(exception);

                return false;
            }
        }

        private RepositoryVersionInformation GetRepositoryVersionInformation()
        {
            string startingPath = this.SolutionDirectory;

            var repositoryVersionInformationLoader = new RepositoryVersionInformationLoader(new VersionTagParser());

            RepositoryVersionInformation repositoryVersionInformation =
                repositoryVersionInformationLoader.GetRepositoryVersionInformation(startingPath);
            return repositoryVersionInformation;
        }

        private static VersionInformation CalculateVersion(RepositoryVersionInformation repositoryVersionInformation)
        {
            var calculator = new VersionCalculator();

            var version = calculator.CalculateVersion(
                repositoryVersionInformation.LastTaggedVersion,
                repositoryVersionInformation.LastTaggedFileVersion,
                repositoryVersionInformation.AnnotationMessage,
                repositoryVersionInformation.CommitsSinceLastTaggedVersion,
                repositoryVersionInformation.PrereleaseOverride);
            return version;
        }

        private void WriteAssemblyInfoContaining(VersionInformation version)
        {
            var settings = new JsonSerializerSettings();
            settings.Converters.Add(new StructConverter());

            string versionAssemblyInfo = string.Format(
                @"// <auto-generated> created by Appccelerate.VersionTask
using System;
using System.Reflection;

[assembly: AssemblyVersion(""{0}"")]
[assembly: AssemblyFileVersion(""{1}"")]
[assembly: AssemblyInformationalVersion(""{2}"")]
/* version: {3} */
",
                version.Version,
                version.FileVersion,
                version.InformationalVersion,
                JsonConvert.SerializeObject(version, settings));

            string tempFolder;
            using (XmlReader projectFileReader = XmlReader.Create(new Uri(this.ProjectFile).AbsoluteUri))
            {
                var project = new Project(projectFileReader);
                var properties = project.AllEvaluatedProperties;
                var property = properties.FirstOrDefault(p => p.Name == "IntermediateOutputPath");

                if (property == null)
                {
                    this.Log.LogError("Could not determine IntermediateOutputPath");
                    throw new Exception("Could not determine IntermediateOutputPath");
                }

                tempFolder = property.EvaluatedValue;
            }

            if (!Directory.Exists(tempFolder))
            {
                Directory.CreateDirectory(tempFolder);
            }

            this.TempAssemblyInfoFilePath = Path.Combine(tempFolder, "Appccelerate.VersionTask.AssemblyInfo.g.cs");

            try
            {
                if (File.Exists(this.TempAssemblyInfoFilePath))
                {
                    var strtStr = "/* version: ";
                    var endStr = " */";
                    var fileText = File.ReadAllText(this.TempAssemblyInfoFilePath);
                    var end = fileText.IndexOf(endStr, StringComparison.InvariantCulture);
                    var start = fileText.IndexOf(strtStr, StringComparison.InvariantCulture) + strtStr.Length;
                    var text = fileText.Substring(start, end - start);

                    var oldVer = JsonConvert.DeserializeObject<VersionInformation>(text, settings);
                    if (version.Version.Equals(oldVer.Version)
                        && version.NugetVersion == oldVer.NugetVersion
                        && version.InformationalVersion == oldVer.InformationalVersion)
                    {
                        this.Log.LogMessage(MessageImportance.Normal, "Current version file represents same version. Skipping rewrite with identical values.");
                        return;
                    }
                }
            }
            catch (Exception exception)
            {
                this.Log.LogError("Could not read version from existing file. Rewriting the file. Exception:" + exception);
            }

            File.WriteAllText(this.TempAssemblyInfoFilePath, versionAssemblyInfo);
        }

        private class StructConverter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var obj = (VersionInformation)value;
                var jobj = new JObject
                {
                    { "Version", obj.Version.ToString(4) },
                    { "FileVersion", obj.Version.ToString(4) },
                    { "NugetVersion", obj.NugetVersion },
                    { "InformationalVersion", obj.InformationalVersion }
                };
                serializer.Serialize(writer, jobj);
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType.AssemblyQualifiedName == typeof(VersionInformation).AssemblyQualifiedName;
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var obj = serializer.Deserialize(reader) as JObject;
                return new VersionInformation(
                    new Version(obj.Value<string>("Version")),
                    new Version(obj.Value<string>("FileVersion")),
                    obj.Value<string>("NugetVersion"),
                    obj.Value<string>("InformationalVersion"));
            }
        }
    }
}